"""
phy.py - Physical Layer

This module handles the conversion between bits and audio waveforms.
It's the "PHY" layer - the lowest level of our modem.

Key concepts:
- A sine wave is generated by: y(t) = amplitude * sin(2 * pi * frequency * t)
- We sample this continuous function at discrete time intervals (sample_rate)
- The result is an array of numbers that the DAC converts to voltage
"""

import numpy as np

# --- Configuration ---

SAMPLE_RATE = 44100  # Samples per second (CD quality)

# FSK frequencies: we use two tones to represent binary
FREQ_0 = 1000  # Hz - represents a '0' bit
FREQ_1 = 2000  # Hz - represents a '1' bit

# Baud rate: how many bits per second we transmit
# Lower = more reliable (more cycles per bit), but slower
BAUD_RATE = 100  # 100 bits per second = 10ms per bit
BIT_DURATION = 1.0 / BAUD_RATE  # seconds per bit
SAMPLES_PER_BIT = int(SAMPLE_RATE * BIT_DURATION)  # 441 samples


def generate_tone(frequency, duration, sample_rate=SAMPLE_RATE, amplitude=0.5):
    """
    Generate a sine wave at the specified frequency.

    Args:
        frequency: Tone frequency in Hz
        duration: Length in seconds
        sample_rate: Samples per second
        amplitude: Peak amplitude (0.0 to 1.0)

    Returns:
        numpy array of float32 samples
    """
    # Create array of time values: [0, 1/sr, 2/sr, ..., duration]
    num_samples = int(sample_rate * duration)
    t = np.arange(num_samples) / sample_rate

    # Generate sine wave: y = A * sin(2Ï€ft)
    wave = amplitude * np.sin(2 * np.pi * frequency * t)

    return wave.astype(np.float32)


def encode_bit(bit):
    """
    Convert a single bit (0 or 1) to its audio waveform.

    Args:
        bit: Integer 0 or 1

    Returns:
        numpy array of samples representing that bit
    """
    frequency = FREQ_1 if bit else FREQ_0
    return generate_tone(frequency, BIT_DURATION)


def encode_byte(byte_value):
    """
    Convert a byte (0-255) to audio waveform.

    Transmits MSB (most significant bit) first.

    Args:
        byte_value: Integer 0-255

    Returns:
        numpy array of samples representing all 8 bits
    """
    waveforms = []

    # Extract bits from MSB to LSB
    for i in range(7, -1, -1):
        bit = (byte_value >> i) & 1
        waveforms.append(encode_bit(bit))

    return np.concatenate(waveforms)


def encode_bytes(data):
    """
    Convert a sequence of bytes to audio waveform.

    Args:
        data: bytes object or list of integers

    Returns:
        numpy array of samples
    """
    waveforms = [encode_byte(b) for b in data]
    return np.concatenate(waveforms)


# --- Decoding (Reception) ---

def decode_bit(samples):
    """
    Decode a single bit from audio samples using FFT.

    Args:
        samples: numpy array of SAMPLES_PER_BIT samples (441)

    Returns:
        Integer 0 or 1
    """
    # Compute FFT - get frequency spectrum
    spectrum = np.abs(np.fft.rfft(samples))

    # Calculate which bin corresponds to each frequency
    # bin = frequency / (sample_rate / num_samples)
    freq_resolution = SAMPLE_RATE / len(samples)  # Hz per bin

    bin_0 = int(FREQ_0 / freq_resolution)  # 1000 / 100 = 10
    bin_1 = int(FREQ_1 / freq_resolution)  # 2000 / 100 = 20

    # Compare amplitudes at the two frequencies
    if spectrum[bin_1] > spectrum[bin_0]:
        return 1
    else:
        return 0


def decode_byte(samples):
    """
    Decode a byte from audio samples.

    Args:
        samples: numpy array of 8 * SAMPLES_PER_BIT samples (3528)

    Returns:
        Integer 0-255
    """
    byte_value = 0

    for i in range(8):
        # Extract samples for this bit
        start = i * SAMPLES_PER_BIT
        end = start + SAMPLES_PER_BIT
        bit_samples = samples[start:end]

        # Decode the bit
        bit = decode_bit(bit_samples)

        # Shift into position (MSB first)
        byte_value = (byte_value << 1) | bit

    return byte_value


def decode_bytes(samples, num_bytes):
    """
    Decode multiple bytes from audio samples.

    Args:
        samples: numpy array of audio samples
        num_bytes: number of bytes to decode

    Returns:
        bytes object
    """
    result = []
    samples_per_byte = SAMPLES_PER_BIT * 8

    for i in range(num_bytes):
        start = i * samples_per_byte
        end = start + samples_per_byte
        byte_samples = samples[start:end]

        byte_value = decode_byte(byte_samples)
        result.append(byte_value)

    return bytes(result)
